import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable, distinctUntilChanged } from 'rxjs';
import { ChatConversation, ChatMessage, Citation, UUID } from '../models.interface';

// ============= Store Class =============

class ConversationStore {
  private conversations: Map<UUID, ChatConversation> = new Map();
  private conversationsList: ChatConversation[] = [];

  add(conversation: ChatConversation): void {
    this.conversations.set(conversation.id, conversation);
    this.conversationsList.push(conversation);
  }

  update(id: UUID, conversation: Partial<ChatConversation>): void {
    const existing = this.conversations.get(id);
    if (existing) {
      const updated = { ...existing, ...conversation, lastModified: new Date().toISOString() };
      this.conversations.set(id, updated);
      const index = this.conversationsList.findIndex(c => c.id === id);
      if (index !== -1) {
        this.conversationsList[index] = updated;
      }
    }
  }

  delete(id: UUID): void {
    this.conversations.delete(id);
    this.conversationsList = this.conversationsList.filter(c => c.id !== id);
  }

  get(id: UUID): ChatConversation | undefined {
    return this.conversations.get(id);
  }

  getAll(): ChatConversation[] {
    return [...this.conversationsList];
  }

  clear(): void {
    this.conversations.clear();
    this.conversationsList = [];
  }
}

// ============= Logger =============

interface ILogger {
  log(message: string, ...args: any[]): void;
  error(message: string, ...args: any[]): void;
  warn(message: string, ...args: any[]): void;
}

class ConsoleLogger implements ILogger {
  log(message: string, ...args: any[]): void {
    console.log(`[AIChatService] ${message}`, ...args);
  }

  error(message: string, ...args: any[]): void {
    console.error(`[AIChatService] ${message}`, ...args);
  }

  warn(message: string, ...args: any[]): void {
    console.warn(`[AIChatService] ${message}`, ...args);
  }
}

// ============= Date Provider =============

class DateProvider {
  now(): string {
    return new Date().toISOString();
  }
}

// ============= AI Chat Engine =============

class AIChatEngine {
  async generateResponse(
    userMessage: string,
    conversationHistory: ChatMessage[],
    context?: string
  ): Promise<{ content: string; citations?: Citation[] }> {
    // TODO: Integrate with actual AI API (OpenAI, Claude, etc.)
    console.log('Generating AI response for:', userMessage);
    console.log('Context:', context);

    // Simulate API call delay
    await this.delay(1500);

    // Mock response based on context
    let response = `Based on the course materials, ${userMessage.toLowerCase().includes('what') ? 'here is what I found:' : 'I can help with that.'}\n\n`;
    response += 'This is a mock AI response that would typically be generated by an AI model like GPT-4 or Claude. ';
    response += 'In a production environment, this would provide detailed answers based on the course content, ';
    response += 'lecture notes, PDFs, and other learning materials associated with the module.';

    // Mock citations
    const citations: Citation[] = [
      {
        contentId: this.generateId(),
        contentName: 'Lecture Notes - Week 1',
        excerpt: 'Relevant excerpt from the course material...',
        page: 5
      }
    ];

    return { content: response, citations };
  }

  async suggestFollowUpQuestions(lastMessage: ChatMessage): Promise<string[]> {
    // TODO: Integrate with AI API for question suggestions
    await this.delay(500);

    return [
      'Can you explain this concept in simpler terms?',
      'What are some practical examples of this?',
      'How does this relate to previous topics?',
      'Are there any common mistakes to avoid?'
    ];
  }

  private generateId(): UUID {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ============= Context Builder =============

class ContextBuilder {
  buildContext(
    courseId?: UUID,
    moduleId?: UUID,
    contentIds?: UUID[]
  ): string {
    // TODO: Fetch actual content from the services to build context
    // This would include: course description, module content, related documents, notes, etc.
    let context = '';

    if (courseId) {
      context += `Course ID: ${courseId}\n`;
    }

    if (moduleId) {
      context += `Module ID: ${moduleId}\n`;
    }

    if (contentIds && contentIds.length > 0) {
      context += `Related Content IDs: ${contentIds.join(', ')}\n`;
    }

    context += '\n[This would include the actual content from courses, modules, documents, notes, etc.]';

    return context;
  }

  extractRelevantContent(
    query: string,
    availableContent: any[]
  ): any[] {
    // TODO: Implement semantic search or keyword matching to find relevant content
    // This would use vector embeddings or text similarity
    return availableContent.slice(0, 5); // Mock: return first 5 items
  }
}

// ============= Main Service =============

@Injectable({
  providedIn: 'root'
})
export class AIChatService {
  private conversationStore = new ConversationStore();
  private logger: ILogger = new ConsoleLogger();
  private dateProvider = new DateProvider();
  private chatEngine = new AIChatEngine();
  private contextBuilder = new ContextBuilder();

  // Observables
  private conversationsSubject = new BehaviorSubject<ChatConversation[]>([]);
  public conversations$ = this.conversationsSubject.asObservable().pipe(distinctUntilChanged());

  // Active conversation
  private activeConversationId: UUID | null = null;

  // Error subject
  private errorSubject = new BehaviorSubject<string | null>(null);
  public error$ = this.errorSubject.asObservable();

  constructor() {
    this.logger.log('AIChatService initialized');
  }

  // ============= Conversation Management =============

  createConversation(
    title: string,
    courseId?: UUID,
    moduleId?: UUID,
    contentIds?: UUID[]
  ): ChatConversation {
    try {
      const context = this.contextBuilder.buildContext(courseId, moduleId, contentIds);

      const conversation: ChatConversation = {
        id: this.generateId(),
        courseId,
        moduleId,
        contentIds,
        title,
        messages: [],
        context,
        isActive: true,
        lastMessageDate: this.dateProvider.now(),
        dateCreated: this.dateProvider.now(),
        lastModified: this.dateProvider.now()
      };

      // Add system message
      const systemMessage: ChatMessage = {
        id: this.generateId(),
        conversationId: conversation.id,
        role: 'SYSTEM',
        content: 'Hello! I\'m your AI learning assistant. I can help you understand course materials, answer questions, and provide explanations. What would you like to know?',
        timestamp: this.dateProvider.now()
      };

      conversation.messages.push(systemMessage);

      this.conversationStore.add(conversation);
      this.conversationsSubject.next(this.conversationStore.getAll());
      this.activeConversationId = conversation.id;
      this.logger.log('Conversation created:', conversation.id);

      return conversation;
    } catch (error) {
      this.handleError('Failed to create conversation', error);
      throw error;
    }
  }

  updateConversation(id: UUID, updates: Partial<ChatConversation>): void {
    this.conversationStore.update(id, updates);
    this.conversationsSubject.next(this.conversationStore.getAll());
  }

  deleteConversation(id: UUID): void {
    if (this.activeConversationId === id) {
      this.activeConversationId = null;
    }
    this.conversationStore.delete(id);
    this.conversationsSubject.next(this.conversationStore.getAll());
    this.logger.log('Conversation deleted:', id);
  }

  getConversationById(id: UUID): ChatConversation | undefined {
    return this.conversationStore.get(id);
  }

  getAllConversations(): ChatConversation[] {
    return this.conversationStore.getAll().sort((a, b) => {
      return new Date(b.lastMessageDate).getTime() - new Date(a.lastMessageDate).getTime();
    });
  }

  getConversationsByCourse(courseId: UUID): ChatConversation[] {
    return this.conversationStore.getAll()
      .filter(c => c.courseId === courseId)
      .sort((a, b) => new Date(b.lastMessageDate).getTime() - new Date(a.lastMessageDate).getTime());
  }

  getConversationsByModule(moduleId: UUID): ChatConversation[] {
    return this.conversationStore.getAll()
      .filter(c => c.moduleId === moduleId)
      .sort((a, b) => new Date(b.lastMessageDate).getTime() - new Date(a.lastMessageDate).getTime());
  }

  getActiveConversation(): ChatConversation | null {
    if (!this.activeConversationId) return null;
    return this.conversationStore.get(this.activeConversationId) || null;
  }

  setActiveConversation(conversationId: UUID): void {
    const conversation = this.conversationStore.get(conversationId);
    if (conversation) {
      // Deactivate previous active conversation
      if (this.activeConversationId) {
        this.conversationStore.update(this.activeConversationId, { isActive: false });
      }

      // Activate new conversation
      this.activeConversationId = conversationId;
      this.conversationStore.update(conversationId, { isActive: true });
      this.conversationsSubject.next(this.conversationStore.getAll());
    }
  }

  // ============= Message Management =============

  async sendMessage(conversationId: UUID, content: string): Promise<ChatMessage> {
    try {
      const conversation = this.conversationStore.get(conversationId);
      if (!conversation) {
        throw new Error(`Conversation with id ${conversationId} not found`);
      }

      // Create user message
      const userMessage: ChatMessage = {
        id: this.generateId(),
        conversationId,
        role: 'USER',
        content,
        timestamp: this.dateProvider.now()
      };

      conversation.messages.push(userMessage);

      // Generate AI response
      const { content: aiContent, citations } = await this.chatEngine.generateResponse(
        content,
        conversation.messages,
        conversation.context
      );

      // Create assistant message
      const assistantMessage: ChatMessage = {
        id: this.generateId(),
        conversationId,
        role: 'ASSISTANT',
        content: aiContent,
        timestamp: this.dateProvider.now(),
        citations
      };

      conversation.messages.push(assistantMessage);

      // Update conversation
      this.conversationStore.update(conversationId, {
        messages: conversation.messages,
        lastMessageDate: this.dateProvider.now()
      });

      this.conversationsSubject.next(this.conversationStore.getAll());
      this.logger.log('Message sent and response received:', conversationId);

      return assistantMessage;
    } catch (error) {
      this.handleError('Failed to send message', error);
      throw error;
    }
  }

  updateMessage(conversationId: UUID, messageId: UUID, updates: Partial<ChatMessage>): void {
    const conversation = this.conversationStore.get(conversationId);
    if (!conversation) return;

    const messageIndex = conversation.messages.findIndex(m => m.id === messageId);
    if (messageIndex !== -1) {
      conversation.messages[messageIndex] = {
        ...conversation.messages[messageIndex],
        ...updates
      };

      this.conversationStore.update(conversationId, { messages: conversation.messages });
      this.conversationsSubject.next(this.conversationStore.getAll());
    }
  }

  deleteMessage(conversationId: UUID, messageId: UUID): void {
    const conversation = this.conversationStore.get(conversationId);
    if (!conversation) return;

    conversation.messages = conversation.messages.filter(m => m.id !== messageId);
    this.conversationStore.update(conversationId, { messages: conversation.messages });
    this.conversationsSubject.next(this.conversationStore.getAll());
    this.logger.log('Message deleted:', messageId);
  }

  starMessage(conversationId: UUID, messageId: UUID): void {
    this.updateMessage(conversationId, messageId, { isStarred: true });
  }

  unstarMessage(conversationId: UUID, messageId: UUID): void {
    this.updateMessage(conversationId, messageId, { isStarred: false });
  }

  provideFeedback(conversationId: UUID, messageId: UUID, feedback: 'HELPFUL' | 'NOT_HELPFUL'): void {
    this.updateMessage(conversationId, messageId, { feedback });
    this.logger.log('Feedback provided for message:', messageId, feedback);
  }

  getStarredMessages(conversationId?: UUID): ChatMessage[] {
    if (conversationId) {
      const conversation = this.conversationStore.get(conversationId);
      return conversation?.messages.filter(m => m.isStarred) || [];
    }

    const allStarredMessages: ChatMessage[] = [];
    this.conversationStore.getAll().forEach(conversation => {
      const starred = conversation.messages.filter(m => m.isStarred);
      allStarredMessages.push(...starred);
    });

    return allStarredMessages;
  }

  // ============= Search & Filter =============

  searchConversations(query: string): ChatConversation[] {
    const lowerQuery = query.toLowerCase();
    return this.conversationStore.getAll().filter(conversation =>
      conversation.title.toLowerCase().includes(lowerQuery) ||
      conversation.messages.some(m => m.content.toLowerCase().includes(lowerQuery))
    );
  }

  searchMessagesInConversation(conversationId: UUID, query: string): ChatMessage[] {
    const conversation = this.conversationStore.get(conversationId);
    if (!conversation) return [];

    const lowerQuery = query.toLowerCase();
    return conversation.messages.filter(m =>
      m.content.toLowerCase().includes(lowerQuery)
    );
  }

  // ============= Suggestions =============

  async getSuggestedQuestions(conversationId: UUID): Promise<string[]> {
    try {
      const conversation = this.conversationStore.get(conversationId);
      if (!conversation || conversation.messages.length === 0) {
        return [];
      }

      const lastMessage = conversation.messages[conversation.messages.length - 1];
      return await this.chatEngine.suggestFollowUpQuestions(lastMessage);
    } catch (error) {
      this.logger.error('Failed to get suggested questions', error);
      return [];
    }
  }

  // ============= Export =============

  exportConversationAsText(conversationId: UUID): string {
    const conversation = this.conversationStore.get(conversationId);
    if (!conversation) return '';

    let output = `Conversation: ${conversation.title}\n`;
    output += `Date: ${new Date(conversation.dateCreated!).toLocaleString()}\n`;
    output += `Course ID: ${conversation.courseId || 'N/A'}\n`;
    output += `Module ID: ${conversation.moduleId || 'N/A'}\n\n`;
    output += '='.repeat(50) + '\n\n';

    conversation.messages.forEach(message => {
      if (message.role !== 'SYSTEM') {
        const timestamp = new Date(message.timestamp).toLocaleString();
        output += `[${timestamp}] ${message.role}:\n`;
        output += `${message.content}\n\n`;

        if (message.citations && message.citations.length > 0) {
          output += 'Citations:\n';
          message.citations.forEach((citation, index) => {
            output += `  ${index + 1}. ${citation.contentName}`;
            if (citation.page) output += ` (Page ${citation.page})`;
            output += '\n';
          });
          output += '\n';
        }
      }
    });

    return output;
  }

  exportConversationAsJSON(conversationId: UUID): string {
    const conversation = this.conversationStore.get(conversationId);
    if (!conversation) return '{}';

    return JSON.stringify(conversation, null, 2);
  }

  // ============= Statistics =============

  getConversationStatistics() {
    const conversations = this.conversationStore.getAll();

    const totalConversations = conversations.length;
    const activeConversations = conversations.filter(c => c.isActive).length;
    const totalMessages = conversations.reduce((sum, c) => sum + c.messages.length, 0);
    const averageMessagesPerConversation = totalConversations > 0
      ? Math.round(totalMessages / totalConversations)
      : 0;

    const starredMessages = this.getStarredMessages().length;

    const messagesWithFeedback = conversations.reduce((sum, c) => {
      return sum + c.messages.filter(m => m.feedback).length;
    }, 0);

    const helpfulFeedbackCount = conversations.reduce((sum, c) => {
      return sum + c.messages.filter(m => m.feedback === 'HELPFUL').length;
    }, 0);

    return {
      totalConversations,
      activeConversations,
      totalMessages,
      averageMessagesPerConversation,
      starredMessages,
      messagesWithFeedback,
      helpfulFeedbackCount
    };
  }

  // ============= Utility Methods =============

  private generateId(): UUID {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private handleError(message: string, error: any): void {
    this.logger.error(message, error);
    this.errorSubject.next(message);
  }

  clearError(): void {
    this.errorSubject.next(null);
  }

  // ============= Data Management =============

  setInitialData(conversations: ChatConversation[]): void {
    this.conversationStore.clear();
    conversations.forEach(conversation => this.conversationStore.add(conversation));
    this.conversationsSubject.next(this.conversationStore.getAll());
    this.logger.log(`Initialized with ${conversations.length} conversations`);
  }

  clearAllData(): void {
    this.conversationStore.clear();
    this.conversationsSubject.next([]);
    this.activeConversationId = null;
    this.logger.log('All data cleared');
  }
}
